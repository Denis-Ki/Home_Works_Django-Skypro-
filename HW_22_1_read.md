1. Для модели продуктов реализуйте механизм CRUD, задействовав модуль
django.forms.
Условия для пользователей:
могут создавать новые продукты,
не могут создавать продукты с запрещенными словами в названии и описании.
Для исключения загрузки запрещенных продуктов реализуйте валидацию названия 
 и описания продукта таким образом, чтобы нельзя было в них добавлять слова: 
 казино, криптовалюта, крипта, биржа, дешево, бесплатно, обман, полиция, радар.

2. Добавьте новую модель «Версия», которая должна содержать следующие поля:
- продукт,
- номер версии,
- название версии,
- признак текущей версии.
При наличии активной версии реализуйте вывод в список продуктов информации об
активной версии.
Признак текущей версии — булево поле, является ли версия для продукта текущей
для отображения на сайте или нет.
Для отображения активной версии расширьте метод get_context_data() 
контроллера списка продуктов, получите данные о версиях продукта 
и выберите текущую (активную) версию для продукта.

3. Добавьте реализацию работы с формами для версий продукта.
Примечание
Все созданные формы нужно стилизовать так, чтобы они были в единой стилистике
оформления всей платформы. Для этого можно воспользоваться методом
__init__ либо самостоятельно изучить пакет crispy-forms.
При стилизации формы методом __init__ можно создать класс-миксин 
для сокращения дублирования кода.
Для стилизации булевого поля используйте специальный стиль — form-check-input.

22_2 
2) В сервисе реализуйте функционал аутентификации, а именно:

Регистрация пользователя по почте и паролю.
Создайте контроллер для регистрации, который будет взаимодействовать с формой регистрации 
— пользователю достаточно ввести почту и пароль.

Верификация почты пользователя через отправленное письмо.
В контроллере регистрации переопределите метод 
form_valid()
 и встройте автоматическую отправку электронного сообщения пользователю на 
указанный в форме регистрации адрес.

Для отправки электронной почты воспользуйтесь встроенной в Django функцией 
send_mail()

Не забудьте настроить почтовый сервер, через который будет происходить отправка электронной почты.
Документацию можно найти тут.

Авторизация пользователя.
Создайте отдельный контроллер для авторизации (LoginView) и зарегистрируйте его в приложении.

Восстановление пароля зарегистрированного пользователя на автоматически сгенерированный пароль.
Создайте новый контроллер для восстановления пароля.

В интерфейсе кнопка «Восстановить пароль» должна отображаться на странице входа.

Пользователь вводит адрес электронной почты, в контроллере происходит генерация пароля, 
перезапись пароля для пользователя с соответсвующим адресом электронной почты 
и отправка сообщения с новым паролем на адрес почты.

Пароль можно сгенерировать с помощью библиотеки random

Помните, что пароль в базе данных хранится в захешированном виде. 
Для установки пароля пользователю можно воспользоваться функцией 
make_password() (посмотреть в документации про эту функцию).

Задание 3
Все контроллеры, которые отвечают за работу с продуктами, закройте для анонимных пользователей, 
при этом создаваемые продукты должны автоматически привязываться к авторизованному пользователю.

Чтобы закрыть контроллеры от анонимных пользователей, добавьте в CBV-контроллеры дополнительное наследование от 
LoginRequiredMixin
 (документация здесь).

Не забудьте добавить поле для продуктов, которое будет указывать на владельца. Оно должно быть ссылкой на модель пользователя.

Для автоматической привязки пользователя к продукту переопределите в контроллере создания продукта метод 
form_valid()
.

Текущий авторизованный пользователь доступен через 
self.request.user
 — запишите его в только что созданный продукт и не забудьте сохранить объект в базу данных.

 
Дополнительное задание
Добавьте интерфейс редактирования профиля пользователя.

 
Дополнительное задание, помеченное звездочкой, желательно, но не обязательно выполнять.